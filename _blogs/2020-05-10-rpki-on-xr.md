---
published: true 
date: '2020-05-10 11:00-0400'
title: Hosting an RPKI ROA cache and RPKI-RTR server on IOS-XR devices  
excerpt: RPKI or Resource Public Key Infrastructure is rapidly being deployed today to provide BGP prefix security across the Internet. In this blog we will show how to host a popular RPKI validator and RTR cache  
author: Phil Bedard 
permalink: /blogs/routinator-hosted-on-xr
tags:
  - rpki
  - peering 
  - internet 
  - security 
position: hidden  
---

{% include toc %}

# Blog Summary 
This blog assumes the reader is already familiar with the basic concepts of BGP, RPKI, and BGP. Some previous knowledge of both Docker and IOS-XR is recommended but not 100% necessary.  We will briefly cover the origins of RPKI, its components, and the basic operation of how a ROA in a regional registry ends up being a part of the BGP route processing criteria on a router. We will utilize Routinator 3000 from NLNet Labs, but the concepts and solution would be similar for other components as well. A list of additional RPKI validators/caches and RPKI-RTR servers is located in the appendix.   

# RPKI Overview 

## Quick RPKI Terminology 

RIR: Regional Internet Registry 
RPKI: Resource Public Key Infrastructure
ROA: Route Origin Authorization 
RTR: RPKI to Router Protocol
RRDP: RPKI Repository Delta Protocol 
Relying Party: Anyone who wants to utilize the RIR ROA data for authorization (You!) 
RPKI Validator: Software for validating ROAs from the RIRs to build a list of prefixes with valid ROAs   
TAL: Trust Anchor Locator
VRP: Validated ROA Payload 
Validated cache: List of validated prefixes, their max prefix length, and their origin ASN  

## What security problems does RPKI solve? 
First and foremost I'll touch upon what problems RPKI solves and what problems it doesn't solve. The initial problem RPKI was created to solve is BGP route hijacking from rogue ASNs. Without RPKI, any ASN connected to the global Internet routing table can originate a prefix and potentially funnel destination traffic to themselves for malicious reasons. There are also ways to create man in the middle attacks by continuing to pass traffic to the original destination while extracting information as it passes through the rogue ASN. Longer prefix hijacking is also possible, since the Internet and routers today route packets based on a longest prefix match criteria. The RPKI infrastructure today can protect against these type of origin hijacks, but does not solve the issue of ASN hijacking or attest to the validity of the end to end chain of BGP advertisements (path validation).   

## How does RPKI solve route origin hijacking?  
In order to verify a BGP prefix advertisement really originated from the organization (ASN) who owns the prefix, we must have a traceable way to attest they are the correct origin ASN for the prefix. 
This is done using X.509 PKI cryptographic certificates with records for organizations, ASNs and IPv4/IPv6 prefixes. The record responsible for certifying prefix validity for an ASN is the Route Origin Authorization record, or ROA. The ROA defined in RFC6482 uses a standard template simply containing the following elements: Authorized origin ASN, IPv4 or IPv6 prefixes, and the maximum length of the prefixes in the ROA. Each ROA is signed with the private key of an organization/ASN for validation by a Relying Party.   

Quoting RFC6483, 

>A resource certificate describes an action by an issuer that binds a list of IP address blocks and Autonomous System (AS) numbers to the subject of a certificate, identified by the unique association of the subject's private key with the public key contained in the resource certificate.  

## How is RPKI data fetched and validated to create a set of "valid" prefixes?  
The steps how ASN and ROA records are used to validate a specific prefix is outlined in RFC6488, section 3. The consumer of the RPKI data, the relying party, must go through these steps in order to validate the signed objects and generate a list of prefixes with a valid cryptographic chain.  The validation software will first use a seeded Trust Anchor Location or TAL for each RIR to begin downloading the chain of certificates used to eventually create prefix data for the router to use. RPKI data is stored in RIR, LIR, and delegated repositories so all of those must be traversed to gather data and validate the objects against the signers public key. RPKI data is downloaded using either rsync (legacy, may be deprecated) or RRDP. RRDP offers a more efficient way to download the data and runs over HTTPS. The validator refreshes its data periodically.   

https://datatracker.ietf.org/doc/draft-ietf-sidrops-rp/ covers Requirements for RPKI Relying Parties with more detail on these procedures.  

Once the validator has validated the signed RPKI objects, it will compile a list of {prefix,maxLength,ASN} entries. The entry is known as a Validated ROA Payload (VRP). The combined list of VRPs form the validated cache of prefixes.    

## How do I get a set of valid prefixes from a ROA validated cache to my router?  
RTR, the RPKI to Router protocol is defined in RFC6810. RTR uses a pull mechanism to download the validated cache data (set of VRPs) from the validator. The cache can signal the router it has new updates, forcing the router to download the new updates, or the router can periodically fetch the entries based on a timer. In IOS-XR the default cache refresh timer is 600 seconds. A serial number is used to keep track of incremental changes in cache data.   

## How do I get my router to do something with the data? 
References on configuring IOS-XR based devices to use RPKI data can be found at https://xrdocs.io/design/blogs/latest-peering-fabric-hld.  We will briefly cover the IOS-XR configuration to the validator cache in the following sections, but not the policy and logic to process routes based on their ROA validation state.   

## IETF RFCs related to RPKI
This is a non-exhaustive list. Please see the SIDR and SIDROPS IETF working groups for a complete list of completed RFCs and in-progress drafts.  

https://tools.ietf.org/html/rfc6480 - An Infrastructure to Support Secure Internet Routing 
https://tools.ietf.org/html/rfc6482 - A Profile for Route Origin Authorizations (ROAs)
https://tools.ietf.org/html/rfc6483 - Validation of Route Origin using PKI and ROAs 
https://tools.ietf.org/html/rfc6810 - The RPKI to Router Protocol (RTR) 

# Routinator 3000 Overview 
Routinator 3000 is a combined RPKI validator and cache combined into a single application. Routinator is developed by NLnet Labs using the Rust programming language. Routinator utilizes the RTR protocol to provide valid prefix data to the downstream routers for announcement validation. The Routinator 3000 project can be found at https://github.com/NLnetLabs/routinator.  

## Future enhancements to RPKI 

### ASPA 
ASPA or Autonomous System Provider Authorization extends the capabilities of RPKI to attend to ASN pairs in a BGP prefix AS path. A new ASPA object will be created with these ASN pairs to validate the AS path for a prefix advertisement. ASPA will add the ability to detect rogue ASNs within the path and not only as origins, giving a means to perform path validation. The latest version of the ASPA draft is located at:  https://tools.ietf.org/html/draft-azimov-sidrops-aspa-profile

### RTRv2 
RTRv2 is being defined in the SIDROPS working group via the https://datatracker.ietf.org/doc/draft-ymbk-sidrops-8210bis/ draft. RTRv2 adds additional capabilities to the existing RTR protocol along with support for ASPA records.   

## Additional information 
Great in-depth information on RPKI: https://rpki.readthedocs.io/en/latest/index.html

# IOS-XR Third Party Applications 
Third party applications or a TPA gives one the ability to run applications not supplied by Cisco on hardware devices and virtual routers like the IOS-XRv9000. Due to the fact IOS-XR 64-bit is based on Linux, it allows a variety of methods for hosting applications on the device. Native Linux applications, Vagrant virtualized environments, and LXC/Docker containers are supported. In this blog we will focus on Docker containers, since Docker is the defacto way of building, distributing, and running Linux applications without having to worry about the base OS and other external dependencies. 

## Brief overview of TPA Networking 
In order to isolate different components in the IOS-XR operating system, Linux namespaces are used. By default, a third party app has no access to the XR global namespace. In addition to the global namespace, each VRF instance created in XR creates a new Linux nanespace. This isolation can be used creatively to limit communication between IOS-XR and third party applications, or between third party applications themselves.  

![](https://xrdocs.github.io/xrdocs-images/assets/images/xr_docker.png)

# Running Routinator as a container in IOS-XR 

## Overview 
The rest of the blog we will work on building a Routinator 3000 Docker container to run on IOS-XR. Routinator will run as both a RPKI validator and a validator cache acting as a RTR server.  

## Container overview 
The Routinator 3000 for XR container is built using an Ubuntu 18.04 base. The resulting image is about 82MB in size. The standard public Routinator docker image uses an Alpine Linux base, which could also be used in this instance, Ubuntu was used more for familiarity than any technical reason. The Github repository will contain Dockerfiles for both an Alpine Linux and Ubuntu based Docker image.   

## Prerequistes 
If you wish to build the Docker container yourself you will need a Linux host (Ubuntu, Centos, etc) with Docker installed. Instructions for installing Docker on different Linux distributions can be found at https://docs.docker.com/get-docker. 

In this blog we will transfer the Docker image to/from the router using the docker save and docker load commands, requiring the user scp the file to the router or XR VM. If using Linux (including downloading from a host to the router) or MacOS the standard scp command will work, Windows will require an scp tool like WinSCP. 

If you wish to load the Docker container from the router using a public or private Docker registry it is 100% supported as long as the router has IP access to the registry. Information on creating a private registry to load containers from is covered in Akshat Sharma's excellent XR third party application blog here: https://xrdocs.io/application-hosting/tutorials/2017-02-26-running-docker-containers-on-ios-xr-6-1-2/#public-dockerhub-registry 

## Building the Docker container 
If you wish to skip ahead and download the prebuilt Docker image you can access the routinator-xr.tar.gz image at this URL and skip ahead to the section on loading the Docker image.  https://github.com/philxor/routinator-xr.tar.gz  

Building the routinator image happens in two steps. First we build the routinator application which requires a much larger Rust compilation environment. We will use Docker's ability to copy files from one image to another during the build stage to copy the Routinator binary to the new IOS-XR container image.  

We will now go over the different components in the Dockerfile used to build the image which will ultimately validate and serve RPKI prefix data to the local XR instance and the rest of the network.  

### Dockerfile build script 
The following is the annotated build file. 

<div class="highlighter-rouge">
<pre class="highlight">
# Build routinator binary for Linux glibc

FROM ubuntu:18.04 as build

ENV http_proxy=http://proxy.esl.cisco.com:80
ENV https_proxy=http://proxy.esl.cisco.com:80


# Add Tini
ENV TINI_VERSION v0.15.0
ADD https://github.com/krallin/tini/releases/download/${TINI_VERSION}/tini /tini

RUN apt-get update && apt-get upgrade -y && apt-get install -y \
  git \
  cargo \
  libssl-dev \
  && rm -rf /var/lib/apt/lists/*

WORKDIR /tmp/routinator

RUN git clone --depth 1 https://github.com/NLnetLabs/routinator .

RUN cargo build \
    --release \
    --locked

# Create actual routinator container with runtime arguments
FROM ubuntu:18.04
COPY --from=build /tmp/routinator/target/release/routinator /usr/local/bin

# Install Tini to capture ^C if running in foreground
COPY --from=build /tini /sbin/tini
RUN chmod +x /sbin/tini

ARG RUN_USER=routinator
#ARG RUN_USER=root
ARG RUN_USER_UID=1012
ARG RUN_USER_GID=1012

RUN apt-get update && apt-get install -y \
  rsync \
#  build-essential \
  iproute2 \
  iputils-ping \
  sudo \
  && rm -rf /var/lib/apt/lists/*

RUN useradd -u $RUN_USER_GID -U $RUN_USER

RUN mkdir -p /home/${RUN_USER}/.rpki-cache/repository /home/${RUN_USER}/.rpki-cache/tals && \
    chown -R ${RUN_USER_UID}:${RUN_USER_GID} /usr/local/bin/routinator /home/${RUN_USER}/.rpki-cache

# Copy TAL files from source to user directory
# Requires acceptance of ARIN TAL at https://www.arin.net/resources/rpki/tal.html

COPY --from=build /tmp/routinator/tals/*.tal /home/${RUN_USER}/.rpki-cache/tals/

#Root option
#COPY --from=build /tmp/routinator/tals/*.tal /root/.rpki-cache/tals/

# Change network namespace to global-vrf for XR usage
COPY entrypoint.sh /entrypoint.sh
RUN chmod +x /entrypoint.sh

#USER $RUN_USER_UID

EXPOSE 3323/tcp
EXPOSE 9556/tcp

ENTRYPOINT ["/sbin/tini", "--", "/entrypoint.sh"]
</pre>  
</div> 

### entrypoint.sh script 
This Routinator Docker image uses an entrypoint script to setup the environment based on options passed via the "docker run" command and then execute routinator. Here is the entire entrypoint.sh script, annotated with comments for each section. The entrypoint.sh script in this case is included as an external file on the host but could be incorporated in the Docker "Dockerfile" build script.  



## Copying the built docker container to an IOS-XR VM or device 
As noted, we will be using the docker save/load commands as opposed to a registry.  On the linux host the docker image was built on execute the following command to save docker image to a .tar file gzip the file to minimize space: 

<div class="highlighter-rouge">
<pre class="highlight">
myhost$ docker save --output routinator-xr.tar && gzip routinator-xr.tar  
</pre>  
</div> 

In this case I will be copying from the host to the router by utilizing scp on the router itself.  

<div class="highlighter-rouge">
<pre class="highlight">
RP/0/RP0/CPU0:Compass-PEF-PE1# bash 
[Compass-PEF-PE1:~]$ scp cisco@myhost:/home/cisco/routinator-xr.tar.gz . &&  gzip -d routinator-xr.tar.gz
</pre>  
</div>

## Loading the docker image into the local registry 

The Docker image is now ready to load. The default user in XR is root so there is no need to sudo to load the docker image. Once loaded we can issue the "docker images" command to view the local images.   

<div class="highlighter-rouge">
<pre class="highlight">
[Compass-PEF-PE1:~]$ docker load --input routinator-xr.tar
[Compass-PEF-PE1:~]$ docker images
REPOSITORY          TAG                 IMAGE ID            CREATED             SIZE
routinator-xr       latest              65e4574eb6cb        20 hours ago        79.51 MB  
</pre>  
</div>

## Running the routinator-xr container 
The complete docker run command with all of its options enabled looks like this, so let's break down each portion, which corresponds to the  

<div class="highlighter-rouge">
<pre class="highlight">
docker run -it --name routinator --cap-add SYS_ADMIN -v /misc/app_host:/data -v /var/run/netns/global-vrf:/var/run/netns/global-vrf -e RSYNC_PROXY=proxy.esl.cisco.com:80 -e RRDP_PROXY=http://proxy.esl.cisco.com:80 -e NS1=171.70.168.183 routinator-xr
</pre>
</div>




